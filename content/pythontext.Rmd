---
title: "R Notebook, Python und UTF-8"
author: "Jörg Kantel"
date: '`r Sys.Date()`'
output:
  tufte::tufte_html:
    css: user.css
    fig_caption: yes
    tufte_features:
    - fonts
    - italics
  html_notebook: default
  tufte::tufte_handout:
    fig_caption: yes
    highlight: tango
    latex_engine: xelatex
  html_document: default
---

## Python im R Notebook -- ein erster Test

Bei meinen Experimenten mit dem neuen R Notebook habe ich nicht nur dieses, sondern auch das Tufte-Paket[^tufte] für einen schöneren HTML- und PDF-/LaTeX-Output entdeckt. Und so habe ich beides zusammen für meine ersten Experimente mit dem R Notebook und Python genutzt.

[^tufte]: http://rstudio.github.io/tufte/

Leider verbindet sich das Notebook zur Zeit nur mit dem Python, was R unter `Sys.witch("python")` findet[^knitr], und das ist leider das (System-) Python 2.7.5 von Apple, nicht jedoch mein Anaconda Python 3.5.

[^knitr]: Das scheint eine Eigenschaft der [Knitr-Language-Engine](http://rmarkdown.rstudio.com/authoring_knitr_engines.html) zu sein.

Man kann das System jedoch überlisten. Zwar gibt untenstehender R-Code wie erwartet das System-Python von Apple aus,

```{r, echo=FALSE, fig.margin = TRUE}
knitr::include_graphics("images/pythonlogo.png")
```

```{r}
Sys.which("python")
```

wenn man jedoch zu Beginn jeder Sitzung

```{r}
Sys.setenv(PATH="/Users/admin/anaconda/bin")
Sys.which("python")
```

eingibt, dann findet auch *R Markdown* das Anaconda Python, der unten stehende Python-3-Code wird korrekt ausgeführt[^sessionpython] und zeigt auch die ausgegebene Liste in UTF-8 mit korrekten Umlauten:

[^sessionpython]: Leider habe ich noch eine Möglichkeit gefunden, wie man dies in einer projektbezogenen Konfigurationsdatei für jedes Projekt permanent machen kann, zur Zeit führe ich den Code mit `echo=FALSE`. einfach zu Beginn eines jeden R-Markdown-Dokuments aus.


```{python}
from collections import Counter
path = "data/aufklaerung.txt"

with open(path, encoding="utf-8", mode="r") as f:
    text = f.read()
print(text)

text= text.lower()
cntr = Counter(text.split())
liste = cntr.most_common()
print(liste[0:5])
```


So schön das Tufte-Paket auch ist, man sieht gleich seine ersten Unzulänglichkeiten: Breite Codezeilen sind zumindest beim HTML-Output nur mit dem ungeliebten, horizontalen Scrollbalken möglich (beim PDF-Output sieht die Geschichte schon besser aus). Und die Bilder in der Randspalte bekommt man nicht mit Markdown, sondern nur mit einem R-Chunk dorthin.

Daher sollte man sich wirklich überlegen, ob man die Funktionalität der Ästhetik opfert. Aber ich bin guter Hoffnung, daß ich -- so wie ich den beigen Hintergrund des Original-Templates zu einem weißen umbiegen konnte -- die Codespalten über die ganze Seitenbreite ziehen kann.

Wie gesagt, im Druck sieht alles schicker aus. Der *Tufte-Handout-Style* ist eben für Druckerzeugnisse entworfen und nicht für Online-Publikationen. Das merkt man deutlich.